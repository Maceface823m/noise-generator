<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Noise Texture Generator</title>
<style>
body { font-family: system-ui,sans-serif; margin:0; background:#f5f5f5; color:#222; display:flex; flex-direction:column; align-items:center; padding:20px;}
h1 { margin-top:0; }
.controls { display:flex; flex-wrap:wrap; justify-content:center; gap:10px; margin-bottom:20px;}
label { display:flex; flex-direction:column; align-items:center; font-size:14px; }
input[type=range], input[type=number], select { width:120px; }
button { cursor:pointer; background:#0078ff; color:#fff; border:none; border-radius:6px; padding:8px 14px; }
button:hover { background:#005fcc; }
canvas { border:1px solid #ccc; image-rendering:pixelated; width:256px; height:256px; }
.param-group { display:none; flex-direction:column; align-items:center; gap:6px; }
footer { text-align:center; font-size:14px; margin-top:12px; }
footer a { color:#0078ff; text-decoration:none; }
</style>
</head>
<body>
<h1>Noise Texture Generator</h1>

<div class="controls">
  <label>Noise Type
    <select id="noiseType">
      <option value="white">White Noise</option>
      <option value="perlin" selected>Perlin</option>
      <option value="simplex">Simplex</option>
      <option value="value">Value Noise</option>
      <option value="worley">Worley (Cellular)</option>
    </select>
  </label>

  <label>Resolution
    <input id="resolution" type="number" min="16" max="2048" value="256" step="16">
  </label>

  <label>Value Steps
    <input id="valueSteps" type="number" min="0" max="256" value="0">
  </label>

  <button id="regenBtn">Regenerate</button>
  <button id="downloadBtn">Download</button>
</div>

<!-- Parameter Groups -->
<div class="controls">
  <div id="perlinParams" class="param-group">
    <label>Scale<input type="range" id="perlinScale" min="1" max="100" value="20"></label>
    <label>Octaves<input type="range" id="perlinOctaves" min="1" max="8" value="4"></label>
    <label>Persistence<input type="range" id="perlinPersistence" min="0.1" max="1" step="0.05" value="0.5"></label>
  </div>

  <div id="simplexParams" class="param-group">
    <label>Scale<input type="range" id="simplexScale" min="1" max="100" value="20"></label>
    <label>Octaves<input type="range" id="simplexOctaves" min="1" max="8" value="4"></label>
    <label>Persistence<input type="range" id="simplexPersistence" min="0.1" max="1" step="0.05" value="0.5"></label>
  </div>

  <div id="valueParams" class="param-group">
    <label>Scale<input type="range" id="valueScale" min="1" max="100" value="20"></label>
    <label>Interpolation
      <select id="valueInterp">
        <option value="linear">Linear</option>
        <option value="cosine">Cosine</option>
        <option value="smoothstep">Smoothstep</option>
      </select>
    </label>
  </div>

  <div id="worleyParams" class="param-group">
    <label>Cells<input type="number" id="worleyCells" min="1" max="50" value="8"></label>
    <label>Distance
      <select id="worleyDist">
        <option value="euclidean">Euclidean</option>
        <option value="manhattan">Manhattan</option>
      </select>
    </label>
  </div>
</div>

<canvas id="canvas" width="256" height="256"></canvas>

<footer>
  â˜• <a href="https://www.buymeacoffee.com/maceokeefe" target="_blank">Buy me a coffee</a>
</footer>

<script>
/* ==== Perlin Noise ==== */
class Perlin {
  constructor(seed=Math.random()*9999){this.gradients={};this.memory={};this.seed=seed;}
  randVect(){const theta=Math.random()*2*Math.PI; return {x:Math.cos(theta),y:Math.sin(theta)};}
  dotProdGrid(x,y,vx,vy){
    const key=vx+','+vy;
    let g=this.gradients[key];
    if(!g){Math.random=this.mulberry32(vx*374761393+vy*668265263+this.seed); g=this.randVect(); this.gradients[key]=g;}
    const dx=x-vx, dy=y-vy; return dx*g.x+dy*g.y;
  }
  smooth(t){return t*t*(3-2*t);}
  interp(x,a,b){return a+this.smooth(x)*(b-a);}
  get(x,y){
    if(this.memory.hasOwnProperty([x,y])) return this.memory[[x,y]];
    const xf=Math.floor(x), yf=Math.floor(y);
    const tl=this.dotProdGrid(x,y,xf,yf);
    const tr=this.dotProdGrid(x,y,xf+1,yf);
    const bl=this.dotProdGrid(x,y,xf,yf+1);
    const br=this.dotProdGrid(x,y,xf+1,yf+1);
    const xt=this.interp(x-xf,tl,tr), xb=this.interp(x-xf,bl,br);
    const v=this.interp(y-yf,xt,xb);
    this.memory[[x,y]]=v; return v;
  }
  mulberry32(a){return function(){var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296;}}
}

/* ==== Value Noise ==== */
function valueNoise(x,y,scale,interpType,randGrid){
  const xf=Math.floor(x), yf=Math.floor(y);
  const tl=randGrid[xf][yf], tr=randGrid[xf+1][yf]||Math.random(), bl=randGrid[xf][yf+1]||Math.random(), br=randGrid[xf+1][yf+1]||Math.random();
  const dx=x-xf, dy=y-yf;
  let f;
  if(interpType==='linear'){f=(a,b,t)=>a+(b-a)*t;}
  else if(interpType==='cosine'){f=(a,b,t)=>a+(b-a)*(1-Math.cos(t*Math.PI))/2;}
  else f=(a,b,t)=>a+(b-a)*(t*t*(3-2*t));
  const xt=f(tl,tr,dx), xb=f(bl,br,dx);
  return f(xt,xb,dy);
}

/* ==== Worley Noise ==== */
function worley(x,y,cells,distanceType,seed){
  const rng = mulberry32(seed);
  let minDist=Infinity;
  for(let i=0;i<cells;i++){
    for(let j=0;j<cells;j++){
      const px=(i+rng())/cells, py=(j+rng())/cells;
      let d;
      if(distanceType==='manhattan') d=Math.abs(px-x)+Math.abs(py-y);
      else d=Math.hypot(px-x,py-y);
      if(d<minDist) minDist=d;
    }
  }
  return minDist;
}
function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296;}}

/* ==== UI ==== */
const canvas=document.getElementById('canvas'), ctx=canvas.getContext('2d');
const noiseTypeEl=document.getElementById('noiseType'), resolutionEl=document.getElementById('resolution');
const valueStepsEl=document.getElementById('valueSteps');
const regenBtn=document.getElementById('regenBtn'), downloadBtn=document.getElementById('downloadBtn');

const paramGroups={
  perlin:document.getElementById('perlinParams'),
  simplex:document.getElementById('simplexParams'),
  value:document.getElementById('valueParams'),
  worley:document.getElementById('worleyParams'),
  white:null
};

const controls={
  perlin:{scale:document.getElementById('perlinScale'), octaves:document.getElementById('perlinOctaves'), persistence:document.getElementById('perlinPersistence')},
  simplex:{scale:document.getElementById('simplexScale'), octaves:document.getElementById('simplexOctaves'), persistence:document.getElementById('simplexPersistence')},
  value:{scale:document.getElementById('valueScale'), interp:document.getElementById('valueInterp')},
  worley:{cells:document.getElementById('worleyCells'), dist:document.getElementById('worleyDist')}
};

let seed=Math.random()*9999;
let perlin=new Perlin(seed);

function updateParamGroup(){
  Object.values(paramGroups).forEach(g=>{if(g) g.style.display='none';});
  const t=noiseTypeEl.value;
  if(paramGroups[t]) paramGroups[t].style.display='flex';
}
noiseTypeEl.addEventListener('change',()=>{updateParamGroup(); generate();});
updateParamGroup();

/* Debounce */
let debounceTimer;
function scheduleGenerate(){clearTimeout(debounceTimer); debounceTimer=setTimeout(generate,50);}

/* Input listeners */
[resolutionEl, valueStepsEl, regenBtn,
 controls.perlin.scale, controls.perlin.octaves, controls.perlin.persistence,
 controls.simplex.scale, controls.simplex.octaves, controls.simplex.persistence,
 controls.value.scale, controls.value.interp,
 controls.worley.cells, controls.worley.dist
].forEach(el=>{
  if(el) el.addEventListener('input',scheduleGenerate);
});
regenBtn.addEventListener('click',()=>{seed=Math.random()*9999; perlin=new Perlin(seed); generate();});

/* ==== Generate ==== */
function generate(){
  const size=parseInt(resolutionEl.value);
  const off=document.createElement('canvas');
  off.width=off.height=size;
  const offCtx=off.getContext('2d');
  const imgData=offCtx.createImageData(size,size);

  const type=noiseTypeEl.value;
  const steps=parseInt(valueStepsEl.value);

  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      let val=0;
      const nx=x/size, ny=y/size;

      if(type==='white'){val=Math.random();}
      else if(type==='perlin'){
        let scale=parseFloat(controls.perlin.scale.value);
        let oct=parseInt(controls.perlin.octaves.value);
        let pers=parseFloat(controls.perlin.persistence.value);
        let freq=1/scale, amp=1;
        for(let o=0;o<oct;o++){val+=perlin.get(x*freq,y*freq)*amp; freq*=2; amp*=pers;}
        val=(val+1)/2;
      }
      else if(type==='simplex'){ // placeholder with Perlin
        let scale=parseFloat(controls.simplex.scale.value);
        let oct=parseInt(controls.simplex.octaves.value);
        let pers=parseFloat(controls.simplex.persistence.value);
        let freq=1/scale, amp=1;
        for(let o=0;o<oct;o++){val+=perlin.get(x*freq,y*freq)*amp; freq*=2; amp*=pers;}
        val=(val+1)/2;
      }
      else if(type==='value'){
        const scale=parseFloat(controls.value.scale.value);
        const interp=controls.value.interp.value;
        const grid={};
        for(let i=0;i<size+2;i++){grid[i]={};for(let j=0;j<size+2;j++) grid[i][j]=Math.random();}
        val=valueNoise(x/scale,y/scale,scale,interp,grid);
      }
      else if(type==='worley'){
        const cells=parseInt(controls.worley.cells.value);
        const dist=controls.worley.dist.value;
        val=worley(nx,ny,cells,dist,seed);
        val=Math.min(val*2,1);
      }

      if(steps>0) val = Math.round(val*(steps-1))/(steps-1);
      val=Math.min(Math.max(val,0),1);
      const c=Math.floor(val*255);

      const idx=(y*size+x)*4;
      imgData.data[idx]=c;
      imgData.data[idx+1]=c;
      imgData.data[idx+2]=c;
      imgData.data[idx+3]=255;
    }
  }

  offCtx.putImageData(imgData,0,0);
  ctx.imageSmoothingEnabled=false;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(off,0,0,canvas.width,canvas.height);
  canvas.offscreenImage=off;
}

downloadBtn.addEventListener('click',()=>{
  if(!canvas.offscreenImage) return;
  const link=document.createElement('a');
  link.download='noise.png';
  link.href=canvas.offscreenImage.toDataURL('image/png');
  link.click();
});

generate();
</script>
</body>
</html>
